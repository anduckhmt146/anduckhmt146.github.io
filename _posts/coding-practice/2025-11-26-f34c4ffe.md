---
layout: post
title: Framework Thinking - Neetcode 150 - Find Minimum in Rotated Sorted Array
date: 2025-11-26
categories: coding-practice
---

Here is solutions for Find Minimum in Rotated Sorted Array.

# 1. Understand the Problem

- You're given a sorted array rotated at some pivot, and all elements are distinct. Return the minimum element.

```python
[3, 4, 5, 1, 2] → 1
[1, 2, 3, 4] (not rotated) → 1
[2, 1] → 1
```

# 2. Clarify Constraints & Ask Questions

1. Are all elements unique?

- Yes.

2. Is array sorted in ascending order before rotation?

- Yes.

3. Is rotation exactly one segment shift?

- Yes, but may not rotate at all.

4. What is min array size?

- At least 1 element.

5. Negative numbers allowed?

- Yes.

6. Time constraints?

- Ideally O(log N) → use Binary Search.

| Case            | Example               | Expected         |
| --------------- | --------------------- | ---------------- |
| Single element  | `[5]`                 | 5                |
| Already sorted  | `[1,2,3]`             | 1                |
| Fully rotated   | `[2,3,1]`             | 1                |
| Two elements    | `[2,1]`               | 1                |
| Large input     | Up to (10^5) elements | Efficient needed |
| Negative values | `[-3,-2,-1]`          | -3               |

# 3. Explore Examples

| Input             | Output | Why                 |
| ----------------- | ------ | ------------------- |
| `[3,4,5,1,2]`     | 1      | Rotation at index 3 |
| `[4,5,6,7,0,1,2]` | 0      | Rotation at index 4 |
| `[1,2,3,4]`       | 1      | Already sorted      |
| `[2,1]`           | 1      | Rotated once        |
| `[1]`             | 1      | Single element      |

# 4. Brainstorm 2-3 solutions

## 4.1. Solution 1: Naive Solution - O(N)

- Traverse entire array → find min

- Time: O(n)

- Space: O(1).

## 4.2. Solution 2: Optimized (Binary Search — O(log n))

Key idea:

- If mid > right, minimum is right half

- If mid < right, minimum is left half (including mid)

# 5. Implement solutions

## 5.1. Brute Force - O(N)

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        return min(nums)
```

- Time: O(N).

- Space: O(1).

## 5.2. Binary Search (Handle duplicates) - O(logN)

Key idea:

- If mid >= right, minimum is right half

- If mid < right, minimum is left half (including mid)

=> But problems in the duplicate value: [1,1,1,1,0,1]

```python
class Solution:
    def findMin(self, nums):
        left, right = 0, len(nums) - 1

        while left < right:
            mid = (left + right) // 2

            if nums[mid] > nums[right]:
                left = mid + 1
            elif nums[mid] < nums[right]:
                right = mid
            else:  # nums[mid] == nums[right]
                right -= 1  # shrink search space

        return nums[left]

```

- Time: O(logN).

- Space: O(1).
