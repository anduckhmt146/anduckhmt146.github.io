---
layout: post
title: Framework Thinking - Neetcode 150 - Merge K Sorted Linked Lists
date: 2025-12-01
categories: coding-practice
---

Here is solutions for .

# 1. Understand the problem

- You are given an array of k linked lists, each list is sorted in ascending order.

- Your task: merge all the linked lists into one sorted linked list and return its head.

# 2. Clarify constraints, asks 4 - 5 questions including edge cases.

1. What is the maximum number of lists k and maximum nodes per list?

2. Can some lists be empty (None)?

3. Can all lists be empty?

4. Are list values bounded (for integer overflow concerns)?

5. Do we modify existing lists or create a new one?

# 3. Explore examples.

- Example 1:

```python
lists = [
  1 -> 4 -> 5,
  1 -> 3 -> 4,
  2 -> 6
]
1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6
```

- Example 2:

```python
lists = []
Output: []
```

- Example 3:

```python
lists = [ [], [1] ]
Output: 1
```

# 4. Brainstorm 2 - 3 solutions

## 4.1. Naive Solution: Merge One by One - Time O(k \* n), Space: O(1) extra space

- Merge list1 & list2 => result

- Merge result with list3 => result

- Time: O(k \* n)

- Space: O(1) (no extra data structure)

## 4.2. Divide & Conquer (Optimized): Merge sorted parallel - Time O(N \* logK), Space O(1)

- Merge lists in pairs (like merge sort)

- Time: O(n log k)

- Space: O(1) (no extra data structure)

## 4.3. Min-Heap (Priority Queue) - Time O(N \* logK), Space O(K)

- Push the head of each list into a min-heap (value, index, node)

- Pop smallest, append to result, push its next. N items, but each pop is logK.

- Time: O(n log k)

- Space: O(k)

# 5. Implement solutions.

## 5.1. Very naive solutions - Build array first sort later - Time O(NlogN), Space O(N)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        nodes = []
        for lst in lists:
            while lst:
                nodes.append(lst.val)
                lst = lst.next
        nodes.sort()

        res = ListNode(0)
        cur = res
        for node in nodes:
            cur.next = ListNode(node)
            cur = cur.next
        return res.next
```

- Time: O(NlogN)

- Space: O(N)

## 5.2. Immediate naive solutions - Build array to find min from the head k lists - Time O(N \* K), Space O(1)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        res = ListNode(0)
        cur = res

        while True:
            minNode = -1
            for i in range(len(lists)):
                if not lists[i]:
                    continue
                if minNode == -1 or lists[minNode].val > lists[i].val:
                    minNode = i

            if minNode == -1:
                break
            cur.next = lists[minNode]
            lists[minNode] = lists[minNode].next
            cur = cur.next

        return res.next
```

- Time: O(N \* K)

- Space: O(1)

## 5.3. Naive Solution - Merge Lists One By One - Time O(N \* K), Space O(1)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        if len(lists) == 0:
            return None

        for i in range(1, len(lists)):
            lists[i] = self.mergeList(lists[i - 1], lists[i])

        return lists[-1]

    def mergeList(self, l1, l2):
        dummy = ListNode()
        tail = dummy

        while l1 and l2:
            if l1.val < l2.val:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next
        if l1:
            tail.next = l1
        if l2:
            tail.next = l2
        return dummy.next
```

- Merge 2 lists: O(K + K) = O(2K).

- N pairs => Time: O(N _ 2K) ~ O(N _ K)

- Space: O(1) due to merge to final result

# 6. Dry run testcases.
