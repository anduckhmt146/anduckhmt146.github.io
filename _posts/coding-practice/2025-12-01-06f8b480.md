---
layout: post
title: Framework Thinking - Neetcode 150 - Merge K Sorted Linked Lists
date: 2025-12-01
categories: coding-practice
---

Here is solutions for .

# 1. Understand the problem

- You are given an array of k linked lists, each list is sorted in ascending order.

- Your task: merge all the linked lists into one sorted linked list and return its head.

# 2. Clarify constraints, asks 4 - 5 questions including edge cases.

1. What is the maximum number of lists k and maximum nodes per list?

2. Can some lists be empty (None)?

3. Can all lists be empty?

4. Are list values bounded (for integer overflow concerns)?

5. Do we modify existing lists or create a new one?

# 3. Explore examples.

- Example 1:

```python
lists = [
  1 -> 4 -> 5,
  1 -> 3 -> 4,
  2 -> 6
]
1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6
```

- Example 2:

```python
lists = []
Output: []
```

- Example 3:

```python
lists = [ [], [1] ]
Output: 1
```

# 4. Brainstorm 2 - 3 solutions

## 4.1. Naive Solution: Merge One by One - Time O(k \* n), Space: O(1) extra space

- Merge list1 & list2 => result

- Merge result with list3 => result

- Time: O(k \* n)

- Space: O(1) (no extra data structure)

## 4.2. Divide & Conquer (Optimized): Merge sorted parallel - Time O(N \* logK), Space O(1)

- Merge lists in pairs (like merge sort)

- Time: O(n log k)

- Space: O(1) (no extra data structure)

## 4.3. Min-Heap (Priority Queue) - Time O(N \* logK), Space O(K)

- Push the head of each list into a min-heap (value, index, node)

- Pop smallest, append to result, push its next. N items, but each pop is logK.

- Time: O(n log k)

- Space: O(k)

# 5. Implement solutions.

## 5.1. Very naive solutions - Build array first sort later - Time O(NlogN), Space O(N)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        nodes = []
        for lst in lists:
            while lst:
                nodes.append(lst.val)
                lst = lst.next
        nodes.sort()

        res = ListNode(0)
        cur = res
        for node in nodes:
            cur.next = ListNode(node)
            cur = cur.next
        return res.next
```

- Time: O(n)

- Space: O(n)

# 6. Dry run testcases.
