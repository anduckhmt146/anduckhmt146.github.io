---
layout: post
title: Leetcode 150 - Minimum Number of Arrows to Burst Balloons
date: 2025-10-14
categories: coding-practice
---

# 1. Input, Output, Contrains

1. Input

- points: list of N intervals, where each interval is [start, end] and 1 â‰¤ start â‰¤ end â‰¤ 10^9 (general case).

- Example: points = [[2,6],[1,3],[7,10],[2,4]]

2. Output

- Integer: minimum number of arrows required so that each interval contains at least one arrow (an arrow shot at x bursts every interval that satisfies start â‰¤ x â‰¤ end).

3. Constraints

- General constraints for the typical problem: 1 â‰¤ N â‰¤ 10^5 (or larger depending on problem source)

- Special-case constraint for the O(N) solution below: [1, 1024].

# 2. Dry run ideas

## 2.1. Solution O(NlogN)

```python
input = [2,4], [1,6], [2,8], [10,11], [7,12]
```

- **Step 1:** Fire in 4

[2,4] âœ…

Any later interval whose range includes 4.

Check next intervals:

[1,6]: includes 4 â†’ âœ…

[2,8]: includes 4 â†’ âœ…

[10,11]: 4 not in range â†’ âŒ

[7,12]: 4 not in range â†’ âŒ

- **Step 2:** Find in 11

Burst [10,11] and [7,12]

## 2.2. Solution O(N) - Counting Sort

```python
end	Bucket contents
4	[(2,4)]
6	[(1,6)]
8	[(2,8)]
11	[(10,11)]
12	[(7,12)]
others	[]
```

```python
arrows = 0
arrow_pos = None
```

```python
ðŸ§® end = 4 â†’ bucket = [(2,4)]

Current arrow_pos: None
Interval: [2,4]

Since arrow_pos is None, we need a new arrow â†’ shoot at e = 4

arrows = 1

arrow_pos = 4

Now, any interval containing x = 4 is burst.

ðŸ§® end = 6 â†’ bucket = [(1,6)]

Current arrow_pos = 4

Interval [1,6] â†’ check if already covered:

s â‰¤ arrow_pos â‰¤ e â†’ 1 â‰¤ 4 â‰¤ 6 âœ…
â†’ Already burst â†’ skip

ðŸ§® end = 8 â†’ bucket = [(2,8)]

arrow_pos = 4

s â‰¤ arrow_pos â‰¤ e â†’ 2 â‰¤ 4 â‰¤ 8 âœ…
â†’ Already burst â†’ skip

ðŸ§® end = 11 â†’ bucket = [(10,11)]

arrow_pos = 4

s â‰¤ arrow_pos â‰¤ e â†’ 10 â‰¤ 4 â‰¤ 11 âŒ
â†’ Not covered â†’ new arrow needed.

Shoot arrow at e = 11

arrows = 2

arrow_pos = 11

ðŸ§® end = 12 â†’ bucket = [(7,12)]

arrow_pos = 11

s â‰¤ arrow_pos â‰¤ e â†’ 7 â‰¤ 11 â‰¤ 12 âœ…
â†’ Already burst â†’ skip

ðŸ§® end = 13 â†’ 1024 â†’ all empty â†’ skip
```

# 3. Solution O(NlogN)

```python
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if not points:
            return 0
        # sort by interval end
        points.sort(key=lambda x: x[1])
        arrows = 1
        arrow_pos = points[0][1]  # shoot at end of first interval
        for s, e in points[1:]:
            if s <= arrow_pos <= e:
                continue
            # need another arrow at this interval's end
            arrows += 1
            arrow_pos = e
        return arrows
```

# 4. Solution O(N + 1024) in range [1,1024]

```python
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        R = 1024
        
        if not points:
            return 0
        ends_buckets = [[] for _ in range(R + 1)]

        for s, e in points:
            ends_buckets[e].append((s, e))

        arrows = 0
        current_arrow_pos = None

        for end in range(1, R + 1):
            for s, e in ends_buckets[end]:
                if current_arrow_pos is None or s > current_arrow_pos:
                    arrows += 1
                    current_arrow_pos = e
        return arrows
```