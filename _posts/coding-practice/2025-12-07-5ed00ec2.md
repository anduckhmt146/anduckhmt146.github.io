---
layout: post
title: Framework Thinking - Axon - User Location Key Value Store
date: 2025-12-07
categories: coding-practice
---

Here is solutions for User Location Key Value Store.

# 1. Understand the problem

- We need to design a key-value store where:

  - Key = userId

  - Value = user’s location

- We must support operations like:

  - put(userId, location)

  - get(userId)

- Possibly:

  - Updating locations

  - Querying users by location

  - Handling large scale

So the core problem is:

- Design an efficient way to store, retrieve, and update user locations using a key-value model.

# 2. Clarify constraints, asks 4 - 5 questions including edge cases.

1. Scale

- How many users? (10³, 10⁶, 10⁹?)

2. Reads vs Writes?

- Is this read-heavy (tracking users) or write-heavy (live GPS updates)?

3. Single machine or distributed?

- Do we need historical locations or only the latest?

4. Do we need reverse lookup?

- Example: “Find all users in New York”

# 3. Explore examples.

```python
set(1, t=5,  lat=2, lon=5)
set(1, t=10, lat=3, lon=6)
set(2, t=4,  lat=0, lon=0)
```

```python
get(1, 8)  → (3,6)
get(1, 4)  → (2,5)
get(1, 11) → None
get(2, 1)  → (0,0)
```

# 4. Brainstorm 2 - 3 solutions, naive solution first and optimize later. Explain the key idea of each solution.

- Set: O(1).

- Get: O(logN).

```python
class Location:
    def __init__(self, time, lat, lon):
        self.time = time
        self.lat = lat
        self.lon = lon


class LocationStore:
    def __init__(self):
        self.store = {}  # user_id -> list of Location (sorted by time)

    def set(self, user_id, time, lat, lon):
        if user_id not in self.store:
            self.store[user_id] = []
        self.store[user_id].append(Location(time, lat, lon))  # O(1)

    def _bisect_left(self, times, target):
        left, right = 0, len(times)

        while left < right:
            mid = (left + right) // 2

            if times[mid] < target:
                left = mid + 1
            else:
                right = mid

        return left

    def get(self, user_id, query_time):
        if user_id not in self.store:
            return None

        locations = self.store[user_id]
        times = [loc.time for loc in locations]

        idx = self._bisect_left(times, query_time)

        if idx == len(locations):
            return None

        return locations[idx]

# -------- MAIN --------
store = LocationStore()

store.set(1, 5,  2, 5)
store.set(1, 10, 3, 6)

print(store.get(1, 8))   # {3,6}
print(store.get(1, 4))   # {2,5}
print(store.get(1, 11))  # None
```

# 5. Implement solutions.

# 6. Dry run testcases.
