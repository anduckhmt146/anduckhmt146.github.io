---
layout: post
title: Framework Thinking - Neetcode 150 - Combination Sum 2
date: 2025-12-05
categories: coding-practice
---

Here is solutions for Combination Sum 2.

# 1. Understand the problem

- You are given:

  - candidates[]: can contains duplicate

  - target: integer

- Return all unique combinations where sum = target, each number can only used once, and no duplicate combinations.

# 2. Clarify constraints, asks 4 - 5 questions including edge cases.

1. Can I reuse the element ?

- Can not reuse the element.

2. Can candidates contain duplicates ?

- Yes

3. Can the result contain duplicate combinations ?

- No

4. Does order matter ?

- No [1, 7] is same [7, 1]

5. What if no combination exists ?

- Return empty list []

# 3. Explore examples.

Example 1:

```python
candidates = [10,1,2,7,6,1,5]
target = 8
```

Output:

```python
[1,1,6], [1,2,5], [1,7], [2,6]
```

# 4. Brainstorm 2 - 3 solutions, naive solution first and optimize later. Explain the key idea of each solution.

## 4.1. Naive Backtracking - Time O(2^N), Space: O(2^n)

- Idea: Do not O(2^N \* N) due to each element picked only once.

- Using a set to store the result.

- Time: O(2^N)

- Space: O(2^N)

## 4.2. Optimized Backtracking with Prunning - Time O(2^N), Space O(2^n)

- Idea: Sort it first, and prunning if candidates[i] == candidates[i - 1] and i > n.

- Time: O(2^N)

- Space: O(2^n)

# 5. Implement solutions.

## 5.1. Naive Backtracking - Time O(N \* 2^N), Space O(N \* 2^N)

```python
class Solution:
    def combinationSum2(self, candidates, target):
        res = set()
        candidates.sort()

        def generate_subsets(i, cur, total):
            if total == target:
                res.add(tuple(cur))
                return
            if total > target or i == len(candidates):
                return

            cur.append(candidates[i])
            generate_subsets(i + 1, cur, total + candidates[i])
            cur.pop()

            generate_subsets(i + 1, cur, total)

        generate_subsets(0, [], 0)
        return [set(combination) for combination in res]
```

- Time: O(N \* 2^N).

- Space: O(N \* 2^N)

## 5.2. Backtracking with Prunning - Time O(N \* 2^N), Space O(N)

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        candidates.sort()

        def dfs(i, cur, total):
            if total == target:
                res.append(cur.copy())
                return
            if total > target or i == len(candidates):
                return

            cur.append(candidates[i])
            dfs(i + 1, cur, total + candidates[i])
            cur.pop()

            # Skip duplicate values
            while i + 1 < len(candidates) and candidates[i] == candidates[i+1]:
                i += 1

            dfs(i + 1, cur, total)

        dfs(0, [], 0)
        return res
```

- Time: O(N \* 2^N).

- Space: O(N)

## 5.2. Backtracking with Hash - Time O(N \* 2^N), Space O(N)

# 6. Dry run testcases.
