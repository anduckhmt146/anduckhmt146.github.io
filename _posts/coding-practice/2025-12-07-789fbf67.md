---
layout: post
title: Framework Thinking - Axon - Encrypt, Decrypt, Hash Code
date: 2025-12-07
categories: coding-practice
---

Here is solutions for Encrypt, Decrypt, Hash Code.

# 1. Understand the problem

# 2. Clarify constraints, asks 4 - 5 questions including edge cases.

# 3. Explore examples.

1. Example 1 — Basic Encryption

```python
secret = "abc"
data   = "abc"

a + a = a (0 + 0 = 0)
b + b = d (1 + 1 = 2)
c + c = e (2 + 2 = 4)

Result = "ade"

```

2. Example 2 — Wrapping

```python
secret = "z"
data   = "z"

z = 25, z = 25
25 + 25 = 50 → 50 % 26 = 24 = y

Result = "y"
```

3. Example 3 — Multiple Blocks

```python
secret = "abc"
data   = "abcdef"

Block 1: abc + abc → ade
Block 2: def + abc → d+a=e, e+b=g, f+c=h → egh

Result = "adeegh"

```

4. Example 4 — Hash

```python
secret = "abc"
blocks = ["def", "ghi"]

Step 1: abc + def = d+e+f → "dfh"
Step 2: dfh + ghi → d+g=j, f+h=n, h+i=p → "jnp"

Final hash = "jnp"
```

# 4. Brainstorm 2 - 3 solutions, naive solution first and optimize later. Explain the key idea of each solution.

```python
class Fuzzcryption:
    def __init__(self, secret: str):
        # Secret key and block size
        self.secret = secret
        self.block_size = len(secret)

    def _char_to_num(self, c):
        return ord(c) - ord('a')

    def _num_to_char(self, n):
        return chr(n + ord('a'))

    def encrypt(self, data: str) -> str:
        result = []

        for i, ch in enumerate(data):
            data_val = self._char_to_num(ch)
            secret_val = self._char_to_num(self.secret[i % self.block_size])

            encrypted_val = (data_val + secret_val) % 26
            result.append(self._num_to_char(encrypted_val))

        return "".join(result)

    def decrypt(self, data: str) -> str:
        result = []

        for i, ch in enumerate(data):
            encrypted_val = self._char_to_num(ch)
            secret_val = self._char_to_num(self.secret[i % self.block_size])

            original_val = (encrypted_val - secret_val + 26) % 26
            result.append(self._num_to_char(original_val))

        return "".join(result)

    def hash(self, data: str) -> str:
        # Split data into blocks
        blocks = [
            data[i:i + self.block_size]
            for i in range(0, len(data), self.block_size)
        ]

        # Start with the secret as the initial accumulator
        acc = self.secret

        for block in blocks:
            acc = self._add_strings(acc, block)

        return acc

    def _add_strings(self, s1, s2):
        # Adds two strings character-wise using a=0...z=25 rule
        result = []

        for i in range(len(s1)):
            v1 = self._char_to_num(s1[i])
            v2 = self._char_to_num(s2[i])

            result.append(self._num_to_char((v1 + v2) % 26))

        return "".join(result)

```

# 5. Implement solutions.

# 6. Dry run testcases.
