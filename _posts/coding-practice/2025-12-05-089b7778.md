---
layout: post
title: Framework Thinking - Neetcode 150 - Permutations
date: 2025-12-05
categories: coding-practice
---

Here is solutions for Permutations.

# 1. Understand the problem

- Given an array nums of distinct integers, return all possible permutations. You can return the answer in any order.

- A permutation is a reordering of all elements. For n elements → total permutations = n!

# 2. Clarify constraints, asks 4 - 5 questions including edge cases.

1. Are all numbers distinct?

- Standard version: ✅ Yes

2. Maximum size of nums?

- Usually 1 ≤ n ≤ 6 or n ≤ 10

- Important because n! grows very fast.

3. Output order matters?

- No, any order is accepted.

4. Should we return a list or print?

- Return a list of lists.

5. Edge cases?

- nums = [] → usually return [[]]

- nums = [1] → [[1]]

# 3. Explore examples.

1. Example 1

```python
Input: [1,2,3]
Output:
[
 [1,2,3],
 [1,3,2],
 [2,1,3],
 [2,3,1],
 [3,1,2],
 [3,2,1]
]

```

2. Example 2

```python
Input: [0,1]
Output: [[0,1], [1,0]]
```

3. Example 3

```python
Input: [1]
Output: [[1]]
```

# 4. Brainstorm 2 - 3 solutions, naive solution first and optimize later. Explain the key idea of each solution.

## 4.1. Solution 1 — Naive Backtracking with Used Array - Time O(N \* N!), Space O(N)

- Idea: Build an array and swap in another position.

  - Build permutations one number at a time.

  - Use a used[] array to avoid reusing elements.

  - Try every unused number at each position.

- Time: O(N \* N!)

- Space: O(N) recursion + result storage

## 4.2. In-Place Swapping (Optimized Space)

- Idea:

  - Fix one index at a time.

  - Swap current index with every possible index.

  - Generate permutations without extra space for used[].

- Time: O(N \* N!).

- Space: O(1)

# 5. Implement solutions.

## 5.1. Recursion - Time O(N \* N!), Space O(N \* N!)

- Idea:

```python
perms = self.permute(nums[1:])
```

=> Give me all permutations of the array without the first element.

- Then:

```python
for p in perms:
    for i in range(len(p) + 1):
        insert nums[0] into position i of p
```

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        if len(nums) == 0:
            return [[]]

        perms = self.permute(nums[1:])
        res = []
        for p in perms:
            for i in range(len(p) + 1):
                p_copy = p.copy()
                p_copy.insert(i, nums[0])
                res.append(p_copy)
        return res
```

- Time: O(N \* N!)

- Space: O(N \* N!)

## 5.2. Iteration - Time O(N \* N!), Space O(N \* N!)

- For [], Insert 1:

```python
perms = [[1]]
```

- For [1], Insert 2:

  - Insert at pos 0 → [2,1]

  - Insert at pos 1 → [1,2]

- Insert 3

  - For [2,1]:

    - [3,2,1]

    - [2,3,1]

    - [2,1,3]

  - For [1,2]:

    - [3,1,2]

    - [1,3,2]

    - [1,2,3]

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        perms = [[]]
        for num in nums:
            new_perms = []
            for p in perms:
                for i in range(len(p) + 1):
                    p_copy = p.copy()
                    p_copy.insert(i, num)
                    new_perms.append(p_copy)
            perms = new_perms
        return perms
```

- Time: O(N \* N!)

- Space: O(N \* N!)

## 5.3. Backtracking

# 6. Dry run testcases.
