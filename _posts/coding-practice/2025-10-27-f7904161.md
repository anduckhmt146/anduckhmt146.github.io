---
layout: post
title: Framework Thinking - Neetcode 150 - Longest Consecutive Sequence
date: 2025-10-27
categories: coding-practice
---

# 1. Problem (short restatement)

- Given an unsorted array of integers nums, return the length of the longest sequence of consecutive integers (the integers must be consecutive, but order in the array doesn't matter).

- Example: nums = [100, 4, 200, 1, 3, 2] → longest consecutive sequence is [1,2,3,4] → return 4.

# 2. Clarifying questions

- What are the input constraints? (n max, integer range)

- Can numbers repeat? (Are duplicates allowed? If yes, how should they be handled?)

- Are negative numbers allowed? (Usually yes — they count as normal integers.)

- Is an empty array possible? (Return 0 for empty.)

- Expected time/space tradeoff? (Is O(n) time and O(n) extra space acceptable?)

# 3. Work through example (use several, including edge cases)

- [100, 4, 200, 1, 3, 2] → answer 4 (1,2,3,4)

- [] → 0

- [1] → 1

- [1,2,2,3] → 3 (duplicates ignored; sequence 1,2,3)

- [9,1,4,7,3,-1,0,5,8,-1,6] → 7 (-1,0,1 or 3,4,5,6,7,8,9 → 7)

- Large contiguous block: [1000000, 999999, 1000001] → 3 (negative and large values handled similarly)

# 4. Brainstorm 2–3 solutions

## 4.1. Sort Array

- Sort the array, then scan and count consecutive run lengths (skip duplicates).

- Time: O(n log n) due to sort.

- Space: O(1) or O(n) depending on sort implementation.

## 4.2. Hash set (optimal)

- Put all unique numbers into a set.

- For each number x that is the start of a sequence (i.e. x-1 not in set), iterate x, x+1, x+2, ... while in set and count length. Track max.

- Each number is visited at most once in the inner loop.

- Time: O(n)

- Space: O(n).

## 4.3. Union-Find

- Map values to indices, union adjacent values, then find largest set size => Condtiion: Different 1

- Time: O(n α(n))

- Space: O(n).

### Where does α(n) come from?

Let’s visualize:

- Imagine we keep joining elements into sets with Union-Find.
  Without optimizations, find() could take O(n) in the worst case (a tall chain).

- But with path compression, every time you call find(), the structure flattens — all nodes on that path now directly point to the root.

- After many operations, the height of any tree becomes incredibly small — so small that we can’t express its growth with normal functions like log(n).

That’s where Ackermann’s function and its inverse α(n) come in.

## 4.4. Counting Sort [min(nums), max(nums)]

- Time complexity: O(R).

- Space complexity: O(R)

# 5. Implement solutions

## 5.1. Brute Force

- Start a num.

- Continue to find num + 1, num + 2,... => Until to find the continuous increase.

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        res = 0
        store = set(nums)

        for num in nums:
            streak, curr = 0, num
            while curr in store:
                streak += 1
                curr += 1
            res = max(res, streak)
        return res
```

- Time complexity: O(N^2).

- Space complexity: O(N).

## 5.2. Sorting

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        if not nums:
            return 0
        res = 0
        nums.sort()

        curr, streak = nums[0], 0
        i = 0
        while i < len(nums):
            # Reset count if do not increase more
            if curr != nums[i]:
                curr = nums[i]
                streak = 0

            # Continue to skip 3 if [3,3,4,5,6]
            while i < len(nums) and nums[i] == curr:
                i += 1

            # Counting
            streak += 1
            curr += 1
            res = max(res, streak)
        return res
```

- Time complexity: O(NlogN).

- Space complexity: O(1) or O(N) depending on the sorting algorithm.

## 5.3. Hash Set

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        numSet = set(nums)
        longest = 0

        for num in numSet:
            if (num - 1) not in numSet:
                length = 1
                while (num + length) in numSet:
                    length += 1
                longest = max(length, longest)
            else:
                # Wait for num - 1

        return longest
```

- Time complexity: O(N).

- Space complexity: O(N).

## 5.4. Hash Map

### Step 1: What the algorithm stores

- mp[x] = the length of the consecutive sequence that x belongs to.

- But — to stay efficient — we only really care about the first and last number of each sequence.

- For every interval [L, R], we store:

```python
mp[L] = mp[R] = length_of_sequence
```

### Step 2: We want to update the start and end of the new merged sequence

Let:

```python

left sequence = [L … num-1]
→ its length = mp[num - 1]

right sequence = [num+1 … R]
→ its length = mp[num + 1]

```

=> After inserting num, we merge them into [L … R].

We need to update:

```python
mp[L] = mp[R] = total_length
```

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        mp = defaultdict(int)
        res = 0

        for num in nums:
            if not mp[num]:
                mp[num] = mp[num - 1] + mp[num + 1] + 1
                mp[num - mp[num - 1]] = mp[num]
                mp[num + mp[num + 1]] = mp[num]
                res = max(res, mp[num])
        return res
```

- Time complexity: O(N).

- Space complexity: O(N).

## 5.5. Union Find

## 5.6. Counting Sort
