---
layout: post
title: Google - Product of Array Except Self
date: 2025-10-23
categories: coding-practice
---

# 1. Thinking Process

## 1.1. Goal Recap

- We need an array output where
  output[i] = product of all nums[j] for j != i.

Constraints:

- No division allowed.

- Must run in O(n) time.

- Should use O(1) extra space (output array doesn’t count).

## 1.2. Key Idea — Prefix/Suffix Trick

- Instead of recomputing everything for each i (which would be O(n²)),
  we can reuse partial products.

- Prefix product: product of all numbers before index i

- Suffix product: product of all numbers after index i

Then output[i] = prefix[i] \* suffix[i].

## 1.3. 🚧 Edge Cases (and why this approach handles them)

### 🔹 Case 1: Zeros in the array

- Zeros are tricky because division can’t handle them.

#### Situation A — One zero

Example: [1, 2, 0, 4]

- All products except at index with zero will be 0 (since zero is part of the product).

- The index where zero occurs will be the product of all non-zero numbers → 1*2*4 = 8.

✅ The prefix/suffix approach naturally handles this:

- When computing prefix/suffix, zero resets the cumulative product.

- So only that one position gets the nonzero product, others stay 0.

#### Situation B — Two or more zeros

Example: [1, 0, 3, 0]

- Every product except self will contain at least one zero → all become 0.

- ✅ Still handled correctly — prefix/suffix both end up producing 0 everywhere.

- 💡 No need for special zero logic. The math of prefix/suffix inherently takes care of it.

### 🔹 Case 2: Overflow

- In languages like C++ or Java, products can overflow for large numbers.

=> You’d need long long (C++) or long (Java).
In Python, integers have arbitrary precision, so overflow is fine.

### 🔹 Case 3: Small arrays

- If nums = [1], result should be [1] (by definition, product of “no other elements” is 1).

- Works automatically because prefix/suffix both start from 1.

#### ⏱ Complexity Analysis

- Time Complexity — O(n)

One pass left → right for prefix products.

One pass right → left for suffix products.

Constant-time operations inside each loop.
✅ Total = O(2n) = O(n).

- Space Complexity — O(1) (extra)

Only uses: result array (required output)

One variable suffix_prod for suffix multiplication.
✅ No extra prefix/suffix arrays.

If we count the output array, total space = O(n).
But as per problem definition, output array doesn’t count toward extra space.

# 2. After-Code Walk-Through

```python
def product_except_self(nums: list[int]) -> list[int]:
    n = len(nums)
    result = [1] * n

    for i in range(1,n):
        result[i] = result[i - 1] * nums[i - 1]

    suffix = 1
    for i in range(n - 1, -1, -1):
        result[i] *= suffix
        suffix *= nums[i]

    return result
```

- The first loop seeds result[i] with the product of everything to its left. result[0] stays 1 because nothing.

- The second loop walks right-to-left maintaining suffix, the product of all elements to the right of the current index. Multiplying result[i] (left product) by suffix (right product) yields the desired full product-minus-self.

- Edge case: Handle for 0 value.

- Correctness: For item i, find L[i] \* R[i]

- Time Compexity: Two linear scans -> O(N) time, result hold output O(1) extra space.
