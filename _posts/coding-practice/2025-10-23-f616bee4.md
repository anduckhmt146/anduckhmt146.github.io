---
layout: post
title: Google - Product of Array Except Self
date: 2025-10-23
categories: coding-practice
---

# 1. Thinking Process

## 1.1. Goal Recap

- We need an array output where
  output[i] = product of all nums[j] for j != i.

Constraints:

- No division allowed.

- Must run in O(n) time.

- Should use O(1) extra space (output array doesnâ€™t count).

## 1.2. Key Idea â€” Prefix/Suffix Trick

- Instead of recomputing everything for each i (which would be O(nÂ²)),
  we can reuse partial products.

- Prefix product: product of all numbers before index i

- Suffix product: product of all numbers after index i

Then output[i] = prefix[i] \* suffix[i].

## 1.3. ðŸš§ Edge Cases (and why this approach handles them)

### ðŸ”¹ Case 1: Zeros in the array

- Zeros are tricky because division canâ€™t handle them.

#### Situation A â€” One zero

Example: [1, 2, 0, 4]

- All products except at index with zero will be 0 (since zero is part of the product).

- The index where zero occurs will be the product of all non-zero numbers â†’ 1*2*4 = 8.

âœ… The prefix/suffix approach naturally handles this:

- When computing prefix/suffix, zero resets the cumulative product.

- So only that one position gets the nonzero product, others stay 0.

#### Situation B â€” Two or more zeros

Example: [1, 0, 3, 0]

- Every product except self will contain at least one zero â†’ all become 0.

- âœ… Still handled correctly â€” prefix/suffix both end up producing 0 everywhere.

- ðŸ’¡ No need for special zero logic. The math of prefix/suffix inherently takes care of it.

### ðŸ”¹ Case 2: Overflow

- In languages like C++ or Java, products can overflow for large numbers.

=> Youâ€™d need long long (C++) or long (Java).
In Python, integers have arbitrary precision, so overflow is fine.

### ðŸ”¹ Case 3: Small arrays

- If nums = [1], result should be [1] (by definition, product of â€œno other elementsâ€ is 1).

- Works automatically because prefix/suffix both start from 1.

#### â± Complexity Analysis

- Time Complexity â€” O(n)

One pass left â†’ right for prefix products.

One pass right â†’ left for suffix products.

Constant-time operations inside each loop.
âœ… Total = O(2n) = O(n).

- Space Complexity â€” O(1) (extra)

Only uses: result array (required output)

One variable suffix_prod for suffix multiplication.
âœ… No extra prefix/suffix arrays.

If we count the output array, total space = O(n).
But as per problem definition, output array doesnâ€™t count toward extra space.

# 2. After-Code Walk-Through

```python
def product_except_self(nums: list[int]) -> list[int]:
    n = len(nums)
    result = [1] * n

    for i in range(1,n):
        result[i] = result[i - 1] * nums[i - 1]

    suffix = 1
    for i in range(n - 1, -1, -1):
        result[i] *= suffix
        suffix *= nums[i]

    return result
```

- The first loop seeds result[i] with the product of everything to its left. result[0] stays 1 because nothing.

- The second loop walks right-to-left maintaining suffix, the product of all elements to the right of the current index. Multiplying result[i] (left product) by suffix (right product) yields the desired full product-minus-self.

- Edge case: Handle for 0 value.

- Correctness: For item i, find L[i] \* R[i]

- Time Compexity: Two linear scans -> O(N) time, result hold output O(1) extra space.
