---
layout: post
title: Framework Thinking - SDE Interview
date: 2025-11-10
categories: mindset-psychology
---

Here is framework thinking for SDE Interview.

# 1. Computer Science

1. What ?

2. Why ?

3. Details.

4. Pros, Cons.

5. Use case.

# 2. Coding Interview

1. Understand the problem.

2. Clarify constraints.

3. Explore examples.

4. Brainstorm 2 - 3 solutions: I'll start with a simple approach so we have a baseline, then optimize.

5. Implement solutions.

6. Dry run testcases.

# 3. System Design

Write with 3 main priority in each category, focus on main ideas for the interview, more details in flow (service call service call infras) and dive deep in pros, cons, how to choose solution.

1. Functional requirements
   - Brainstorm about 3 requirements
2. Non-functional requirements
   - Discuss non-FP based on FP
   - Availability, Scalability, Performance
   - Example
     - Availability >> Consistency
     - The system should be able to scale to support 100M+ DAU (Daily Active Users)
     - The system should be low latency, rendering feeds in under 200ms
3. Estimate
   - Example
     - Daily active user
     - Action per user
     - How long you store data
     - Read: Write ratio
   - Daily active user (number of users and interaction read:write)
     - DAU × actions_per_user_per_day = total_requests/day.
     - RPS = total_requests ÷ (24 \* 3600).
   - Storage (number of items)
     - total_records = DAU × records_per_user (if applicable).
     - total_storage = total_records × avg_record_size.
   - Example Assumptions:
     - 300 million monthly active users
     - 50% of users use Twitter daily.
     - Users post 2 tweets per day on average.
     - 10% of tweets contain media.
     - Data is stored for 5 years.
     - Estimations:
       - Example:
         - QPS: (daily_active_user _ action / 24 _ 3600)
         - Storage: (daily_active_user _ action _ 1MB \* time_store)
       - Query per second (QPS) estimate:
         - Daily active users (DAU) = 300 million \* 50% = 150 million
         - Tweets QPS = 150 million \* 2 tweets / 24 hour / 3600 seconds = ~3500
         - Peek QPS = 2 \* QPS = ~7000
     - We will only estimate media storage here. Average tweet size:
       - tweet_id 64 bytes
       - text 140 bytes
       - media 1 MB
       - Media storage: 150 million _ 2 _ 10% \* 1 MB = 30 TB per day
       - 5-year media storage: 30 TB _ 365 _ 5 = ~55 PB
4. API Design
   - Input, Output
   - Endpoint
5. Data Model
   - Schema of entity
   - Explain the description of each field
6. High-level design
   - Data flow for each Functional Requirement: FP 1, FP2,…
   - Visualize the markdown high level design, example
     ```markdown
                               ┌────────────────────────────────────┐
                               │             Mobile Apps             │
                               │     (Rider / Driver Applications)  │
                               └────────────────────────────────────┘
                                                │
                                                ▼
                                ┌────────────────────────────────┐
                                │        API Gateway / LB        │
                                └────────────────────────────────┘
                                                │
             ┌──────────────────────────────────┼────────────────────────────────────┐
             ▼                                  ▼                                    ▼

     ┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐
     │ Fare Service │ │ Trip Service │ │ Search Service │
     │ (FP1) │ │ Request/Status │ │ POI Search │
     └──────────────────┘ └──────────────────┘ └──────────────────┘
     │ │ ▲ │
     │ │ │ │
     ▼ ▼ │ ▼
     ┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐
     │ Routing Service │ │ Matching Engine │ <── driver pings │ Geospatial Index │
     │ (ETA, distance) │ │ (FP3) │ (FP3) │ (RedisGeo/Tile38)│
     └──────────────────┘ └──────────────────┘ └──────────────────┘
     │ │
     │ ▼
     │ ┌──────────────────┐
     │ │ Notification Svc │───► APNs/FCM (Push)
     │ └──────────────────┘
     │
     ▼
     ┌───────────────────────────────────────────────────────────────────────────┐
     │ Data Storage & State │
     ├───────────────────────────────────────────────────────────────────────────┤
     │ • Redis Cluster (Live Trip State, Matching State, Driver Status) │
     │ • SQL DB (Postgres/CockroachDB) — Durable Trip Records, Payments │
     │ • Kafka / Event Bus — Events: ride.requested / accepted / completed │
     │ • Object Storage (S3/GCS) — Map tiles, logs │
     └───────────────────────────────────────────────────────────────────────────┘
     ```
   - What each components do
7. Detailed each requirement FP1, FP2, FP3 (Explain more details)
   1. Option 1
      1. How: Data flow
      2. Pros
      3. Cons
      4. Why to choose
      5. Short Example
   2. Option 2
8. Find bottlenecks and solution for FP1, FP2, FP3
   - Brainstorm bottlenecks
     | Constraint           | Typical Bottleneck            | How to Spot                           |
     | -------------------- | ----------------------------- | ------------------------------------- |
     | **QPS / Throughput** | DB writes, queues             | Estimate expected QPS vs max capacity |
     | **Latency**          | Synchronous I/O, API chaining | Count service hops, network calls     |
     | **Availability**     | Single point failures         | Check if component can fail alone     |
     | **Storage / Growth** | DB size, partitioning         | Estimate data scale over time         |
   - How: Data flow
   - Pros
   - Cons
   - Why to choose ?
   - Short Example
9. Scaling Patterns: Scaling reads, scaling writes, real-time updates, Consistent, Availability, Performance… Give example for edge cases

Notes:

1. Prior to complete design for all requirements.
2. Show 2 3 options and compare pros, cons, decision skills.
3. Dive deep bottlenecks ⇒ Find in user requirements

# 4. Behaviour Interview

- STAR method.

1. Context.

2. Ownership.

3. Contribution.

4. Effective.

5. Learn.
