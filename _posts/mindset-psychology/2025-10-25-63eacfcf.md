---
layout: post
title: Framework of Thinking - Explaining
date: 2025-10-25
categories: mindset-psychology
---

# 1. Thinking Framework

## 1.1. Talk to yourself

- When talk to yourself, you can use "Ti" to analyze and dive deep analyze more and more ?

- Solution: You can ask questions from A, to B, to C,... wandering around anything as long as you satisfy to understand everything deeply.

=> The reason you want is to understand knowledge, and inteligence and ability are your pivot.

## 1.2. Talk to others

- Remember: Other people have different learning curve, they only understand your idea by their learning rate

=> So if they are consume information slower than your delivery speed, they do not understand you. And of course, if they are interviewer or higher title people, it is likely difficult for them to acknowledge that they are wrong or they do not more inteligence than you => they judge you can not explain idea clearly.

- Solution: You must follow a "template" when talking with people, adjust the template with different people.

# 2. Apply for answering questions

## 2.1. Dive deep

1. Result

2. Why

3. Worst case

4. Alernative flow

## 2.2. Storytelling - STAR Method

1. Situation

2. Task

3. Action

4. Result

## 2.3. Small talk

- Find someone that match with your personality.

- More action when interact with others, not only think.

# 3. Template for Coding Interview

## 3.1. Template

1. Understand the problem that you solved: **Do not need to find solution is normal**, used more time to think => let interviewer to interact to fix your misunderstandings.

2. Ask clarify questions: ask for some question about contrains, duplicates, empty case, negative number, time and space complexity expected.

3. Work through example: Random as much as example possible => interviewer can correct your mistakes.

4. Brainstorm 2-3 solutions: naive solutions, optimized solution, compare the time and space complexity for considering optimization => let interviewer to interact to fix your misunderstandings.

5. Implement solution: now to implement this => Code clean, optimized, syntactically correct solution => Real and runnable, correct code.

6. Test your code: walk-through to the code to dry run, and debug testcases in step 3.

## 3.2. Template to say

### Step 1: Understand the Problem

- “Let me restate the problem in my own words to make sure I understand it correctly.”
  [→ Briefly rephrase the problem.]

- “So the goal is to … and I need to return … Is that correct?”
  (Pause and let interviewer confirm or correct your understanding.)

### Step 2: Ask Clarifying Questions

- “Before I start, I have a few quick clarifying questions:”

- “What are the constraints on input size?”

- “Can the input contain duplicates / negatives / empty values?”

- “What should I return in edge cases (e.g., empty input)?”

- “Is there any specific time or space complexity target you expect?”

(This shows thorough thinking and prevents misunderstandings.)

### Step 3: Work Through Examples

- “Let’s go through a few examples to understand the problem better.”
  [→ Walk through 2–3 examples, including edge cases.]

- “So for input X, the expected output is Y because …”
  (Pause to confirm: “Does that look correct to you?”)

### Step 4: Brainstorm Solutions

- “Now let’s think about possible approaches.”

- “Naive approach: … (time complexity O(...), space complexity O(...))”

- “Optimized approach: … (improvement reason: …)”

- “I’ll compare both — the second one seems better because …”
  (Pause: “Do you agree if I go with this optimized approach?”)

### Step 5: Implement the Solution

- “Alright, I’ll start coding the optimized solution now.”
  (Code cleanly, explain as you type.)

- “Here I’m using … because it helps to …”
  (Keep talking so the interviewer can follow your logic.)

### Step 6: Test and Debug

- “Let’s test the code with a few examples from before.”
  [→ Walk through dry runs step by step.]

- “For input X, we get Y — which matches our expectation.”

- “Edge case Z also works because …”

- “So the final complexity is O(...), and it handles all cases correctly.”

[![Watch the video](https://img.youtube.com/vi/Q4C3ZRJLnac/0.jpg)](https://youtu.be/Q4C3ZRJLnac?si=TA4i_NUtqtaAsaYz)

## 3.3. Apply AI to brainstorm and reinforce each steps

[![Watch the video](https://img.youtube.com/vi/q7i5z92G1Us/0.jpg)](https://youtu.be/q7i5z92G1Us?si=It5z8x5t2RwhtkdD)

# 4. Template for System Design

## 4.1. Template

### Step 1: Define the problems

- Functional requirements, non-functional requirements => Draw high-level design based on this.

- Constrains: Performance, Availability, Scalability => Choose 1 most item that matter most.

=> Aim: Clarify scope of the system.

### Step 2: Quick calculation

- Storage capacity

- Bandwidth requirements

=> Aim: Choose the right components and scaling ability.

### Step 3: High-level design (functional requirements)

- Design high-level design for each functional requirement.

- Define APIs to client communicate with server.

- Design database table to store the entity.

### Step 4: Deep dive (non-functional requirements)

- Dive deep some optimize function: caching, CDN, kafka,...

- Answer for non-functional requirements.

### Step 5: Identify bottlenecks and scaling opportunities.

- Handle bottlenecks.

- Handle the failure cases.

- Enhance the scalability opportunities.

### Step 6: Wrap up

- Wrap up and future opportunities.

## 4.2. Template to say

### Step 1: Define the problem

- “Let me restate the problem: we need to build [system name].”

- “Key users: [who uses it]. Main goal: [core purpose].”

- “Functional requirements: [list 2–3].”

- “Non-functional: low latency / high availability / scalability.”

- “Constraint I’ll focus on is [X], because [reason].”

### Step 2: Quick estimation

- “Assume we have [N] users, [QPS], [avg data size].”

- “So total storage ≈ [X TB], bandwidth ≈ [Y GB/day].”

- “That helps size servers and DB choice.”

### Step 3: High-level design

- “At a high level: client → load balancer → app servers → cache → DB.”

- “Add CDN for static content, and queue/workers for async tasks.”

- “APIs example: POST /resource, GET /resource/{id}.”

- “Main DB tables: [table1], [table2].”

### Step 4: Deep dive (optimization)

- “To meet NFRs, I’ll add caching (Redis), CDN, and async queue (Kafka).”

- “Use read replicas / sharding for scale.”

- “Ensure consistency with [strong/eventual] model.”

### Step 5: Bottlenecks & failures

- “Main bottlenecks: DB writes, cache misses, fan-out.”

- “Mitigation: sharding, cache warm-up, async processing.”

- “For failures: add retries, circuit breakers, and failover replicas.”

- Scaling opportunities

### Step 6: Wrap up

- “We achieved [X goal] with [key components].”

- “Trade-off: optimized for [availability/latency], not [consistency/etc.].”

- “Future: add [geo-replication / analytics / ML ranking].”

# 5. Template for Behaviour Interview

Link: [https://anduckhmt146.site/leadership-amazon/](https://anduckhmt146.site/leadership-amazon/)

# 6. Template for Computer Science Interview

1. Application.

2. OS.

3. Network.

# 7. Template for follow-up questions

1. What is theory, e.g. HTTP and HTTPS. ?

2. What is it used in practice ?

3. Have you used in your work ?


