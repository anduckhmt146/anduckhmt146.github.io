---
layout: post
title: Concurreny in Golang -  A Lesson Worth 12k USD from Tiktok
date: 2025-11-23
categories: system-design
---

Here is main idea of concurency in Golang.

# 1. Goroutine

- It is a small virtual threads manage by Go runtime.

# 2. Channel

- Place where multiple goroutines communicate together.
- Use case: use to **batch processing** write database or make conversion API in server.

# 3. Basic Usage Goroutine

```go
func hello(name string) {
	for i := 0; i < 5; i++ {
		fmt.Println("Hello", name)
		time.Sleep(time.Millisecond * 500)
	}
}

func main() {
	go hello("John")
	go hello("Peter")
}
```

```go
Hello John
Hello Peter
Hello Peter
Hello John
Hello Peter
Hello John
Hello John
Hello Peter
Hello Peter
Hello John
```

# 4. Sample deadlock in Goroutine

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	c := make(chan int)
	go process(c)
	for {
		fmt.Println("Received:", <-c)
	}
}

func process(c chan int) {
	for i := 1; i <= 3; i++ {
		c <- i
		time.Sleep(time.Millisecond * 300)
	}
}

```

```go
Received: 1
Received: 2
Received: 3
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan receive]:
main.main()
	/tmp/sandbox708494458/prog.go:13 +0x7d

```

Reason:

- After goroutine send 1,2,3 to the channel.
- Main thread wait for another value from channel â‡’ Nothing send continue â‡’ Deadlock.

Solution:

- Safe consume message
    
    ```go
    for {
    		i, open := <-c
    		if !open {
    			return
    		}
    		fmt.Println("Received:", i)
    	}
    
    ```
    

# 5. Buffered Channel and Unbuffered Channel

```go
package main

import "fmt"

func main() {
	ch := make(chan int)
	ch <- 1
	fmt.Println("Received:", <-ch)
}
```

```go
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan send]:
main.main()
	/tmp/sandbox980511399/prog.go:7 +0x59

```

Reason:

- Unbuffered channel **are synchronized**, ****when produce message to channel ****will block the current thread (main thread) â‡’ deadlock.

Solution:

### Unbuffered Channel

```go
ch := make(chan int) // unbuffered

go func() {
    ch <- 1 // BLOCKS here until main receives
}()
v := <-ch    // main receives, unblocks the goroutine
fmt.Println(v)

```

### Buffered Channel

```go
ch := make(chan int, 1) // capacity = 1

go func() {
    ch <- 1 // DOES NOT block (space available)
}()
time.Sleep(time.Second) // receiver isn't even ready yet
v := <-ch
fmt.Println(v)

```

### Example Buffered Channel still lock when reach the maximum size

```go
ch := make(chan int, 1)
ch <- 1        // OK
ch <- 2        // BLOCKS until someone reads from the channel
```

| Step | Action | Channel State | Sender Status |
| --- | --- | --- | --- |
| 1 | `ch := make(chan int, 1)` | empty | â€” |
| 2 | `ch <- 1` | `[1]` (full) | â€” |
| 3 | `ch <- 2` | blocks (waiting) | ðŸŸ¥ *blocked* |
| 4 | `<-ch` reads `1` | buffer empty | unblocks send |
| 5 | *(Automatically)* | `[2]` now in channel | ðŸŸ¢ send completes |

# 6. Select

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	c1 := make(chan string)
	c2 := make(chan string)

	go sendAndSleep(c1, "Sleep 1s", time.Second*1)
	go sendAndSleep(c2, "Sleep 5s", time.Second*5)

	for {
		fmt.Println("Received:", <-c1)
		fmt.Println("Received:", <-c2)
	}
}

func sendAndSleep(c chan string, value string, duration time.Duration) {
	for {
		c <- value
		time.Sleep(duration)
	}
}

```

Reason:

- It works, but channel 2 need to wait to recieve meesage from channel 1 because recieve <-c1 before â†c2.

Solution:

- Use select to asychronus consume message from channel.
    
    ```go
    	for {
    		select {
    		case v1 := <-c1:
    			fmt.Println("Received:", v1)
    		case v2 := <-c2:
    			fmt.Println("Received:", v2)
    		}
    	}
    
    ```

# 7. Does Go run goroutines in parallel?

   ```go
    runtime.GOMAXPROCS(2)
   ```

- By default Go set GOMAXPROCS = numbers of CPUs.


# 8. Do goroutines run inside threads, if 1 CPU have multiple threads ?

- Goroutines run on OS threads managed by Go runtime, but donâ€™t map 1:1 to threads.
They are much lighter â€” thousands of goroutines can run on a few threads.